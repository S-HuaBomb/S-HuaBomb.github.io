<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkrBang</title>
  
  <subtitle>Doing Is Better Than Done</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://s-huabomb.github.io/"/>
  <updated>2019-10-18T13:11:17.154Z</updated>
  <id>https://s-huabomb.github.io/</id>
  
  <author>
    <name>SkrBanger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>翻译：Let&#39;s Build A Web Server.Part 1</title>
    <link href="https://s-huabomb.github.io/2019/10/18/%E7%BF%BB%E8%AF%91%EF%BC%9ALet&#39;s%20Build%20A%20Web%20Server.Part%201/"/>
    <id>https://s-huabomb.github.io/2019/10/18/翻译：Let&#39;s Build A Web Server.Part 1/</id>
    <published>2019-10-18T09:31:40.000Z</published>
    <updated>2019-10-18T13:11:17.154Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1."></a>Part 1.</h5><p>我在 <a href="https://github.com/S-HuaBomb/Build-a-Web-Server-Translate" target="_blank" rel="noopener">GitHub</a> 上开源了这个系列文章的翻译版（还在跟进原作者的更新），第一次公开翻译英文教程，纯粹兴趣使然，错漏和不严谨在所难免……欢迎提出意见和建议，或者成为 Contributor。</p><p>:books: :books: :books:</p><p>原文：《<a href="https://ruslanspivak.com/lsbaws-part1/" target="_blank" rel="noopener">Let’s Build A Web Server. Part 1.</a>》</p><a id="more"></a><hr><p>&ensp;&ensp;&ensp;&ensp;有一天，一个女人出门散步，来到一个建筑工地，看到三个男人在工作。她问第一个男人，“你在做什么？”，他对这个问题很恼火，咆哮道，“你没看到我在砌砖吗？”；女人不满意他的回答，于是问第二个男人正在做什么。第二个人回答说：“我正在修建一堵砖墙。”，然后他便把注意力转向第一个男人，对他说，“嘿，你刚刚走过墙的尽头，你要拿掉最后那块砖。”；女人再次对回答不满意，于是问第三个人在做什么。那个男人一边仰望天空一边对她说：“我正在建造这个世界上最大的大教堂。”，当他站在那里仰望天空时，另外两个男人开始争论放错的砖块，他转向前两名男子说：“嘿伙计们，不要担心那块砖头。那是一面内墙，它将被覆盖掉，没有人会看到那块砖，继续前进另一层。”</p><p>这个故事的寓意是，当你了解整个系统并了解不同的部分如何组合在一起（砖块，墙壁，大教堂）时，你可以更快地识别和修复问题（放错的砖块）。</p><p>这与从头创建一个 Web 服务器有什么关联？</p><p><strong>我相信想要成为一个更优秀的开发者，你必须对每天在使用的底层软件系统有更好的了解，包括编程语言、编译器和解释器、数据库和操作系统、Web 服务器和框架等。 而且，为了更好、更深入地理解这些系统，你必须从头开始，一步一个脚印地重新构建它们。</strong></p><p>子曰：</p><blockquote><p>“我听到的会忘记”</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190721124746797.png" alt="LSBAWS_confucius_hear"></p><blockquote><p>“我看到的我能记住”</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190721124934194.png" alt="LSBAWS_confucius_see"></p><blockquote><p>“我做过的我就能理解”</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190721125045241.png" alt="LSBAWS_confucius_do"><br>我希望在这一点上你相信通过重新构建不同的软件系统来了解它们的工作原理是个好主意。</p><p>在这个由三部分组成的系列文章中，我将向你展示如何构建自己的基本 Web 服务器。让我们开始吧。</p><p>首先，什么是 Web 服务器？<br><img src="https://img-blog.csdnimg.cn/20190721125715752.png" alt="LSBAWS_HTTP_request_response"><br>简而言之，它是一个位于物理服务器（oops，服务器上的服务器）上的网络服务器，它等待客户端发送请求。当它收到一个请求后，会生成响应并将其发送回客户端。客户端和服务器之间的通信使用 HTTP 协议进行。 客户端可以是您的浏览器或任何其他使用 HTTP 协议的软件。</p><p>Web 服务器的非常简单的实现是什么样的？ 以下是我的示例。示例是在 Python 中（在 Python3.7 +上测试过），但即使你不了解 Python（它是一种非常容易学习的语言，不妨试试！）你仍然应该能够从下面的代码和解释中理解概念：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python3.7+</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST, PORT = <span class="string">''</span>, <span class="number">8888</span></span><br><span class="line"></span><br><span class="line">listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">listen_socket.bind((HOST, PORT))</span><br><span class="line">listen_socket.listen(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">f'Serving HTTP on port <span class="subst">&#123;PORT&#125;</span> ...'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    client_connection, client_address = listen_socket.accept()</span><br><span class="line">    request_data = client_connection.recv(<span class="number">1024</span>)</span><br><span class="line">    print(request_data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    http_response = <span class="string">b"""\</span></span><br><span class="line"><span class="string">HTTP/1.1 200 OK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Hello, World!</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    client_connection.sendall(http_response)</span><br><span class="line">    client_connection.close()</span><br></pre></td></tr></table></figure><br>将上面的代码保存为 <code>webserver1.py</code> 或直接从 <a href="https://github.com/rspivak/lsbaws/tree/master/part1" target="_blank" rel="noopener">GitHub</a> 下载并在命令行上运行，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python webserver1.py</span><br><span class="line">Serving HTTP on port 8888 …</span><br></pre></td></tr></table></figure><br>现在，在 Web 浏览器的地址栏中键入以下 URL：<code>http://localhost:8888/hello</code>，按 Enter 键，然后看到魔法生效。你应该在浏览器中看到“Hello，World”，如下所示：<br><img src="https://img-blog.csdnimg.cn/20190721132606810.png" alt="browser_hello_world"><br>Just do it，认真地。在你测试时我会等着你。</p><p>完成了吗？太好了。现在让我们讨论它到底是如何运作的。</p><p>首先让我们从你输入的网址开始。它被称为URL，这是它的基本结构：<br><img src="https://img-blog.csdnimg.cn/20190721132907507.png" alt="LSBAWS_URL_Web_address"><br>这就是你告诉浏览器如何去查找和连接Web服务器的地址、以及要为你提取的服务器上的页面（路径）的方式。 在你的浏览器发送 HTTP 请求之前，它首先需要与 Web 服务器建立 TCP 连接。 然后它通过 TCP 连接向服务器发送 HTTP 请求，并等待服务器发回 HTTP 响应。 当您的浏览器收到响应时就会显示它，在这个示例中它显示“Hello，World！”</p><p>让我们更详细地探讨客户端和服务器在发送 HTTP 请求和响应之前如何建立 TCP 连接。为实现连接，它们都使用所谓的“套接字”。你不要直接使用浏览器，而是在命令行上使用 telnet 手动模拟浏览器。</p><p>在运行 Web 服务器的同一台计算机上，在新的命令行上启动 telnet 会话，指定连接到 localhost 的主机和 8888 端口，然后按 Enter 键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ telnet localhost 8888</span><br><span class="line">正在连接 localhost …</span><br><span class="line">Connected to localhost.</span><br></pre></td></tr></table></figure><br>此时，你已与本地主机上运行的 Web 服务器建立 TCP 连接，并准备发送和接收 HTTP 消息。 在下图中，你可以看到服务器接受新的 TCP 连接必须经历的标准过程：<br><img src="https://img-blog.csdnimg.cn/20190721141111563.png" alt="LSBAWS_socket"><br>在同一个 telnet 会话中键入 <code>GET /hello HTTP/1.1</code> 然后 Enter 键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ telnet localhost 8888</span><br><span class="line">Trying 127.0.0.1 …</span><br><span class="line">Connected to localhost.</span><br><span class="line">GET /hello HTTP/1.1</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></p><blockquote><p>译者注：在 Win10 的命令行中似乎无法完成，因为在你输入第一个字母的时候连接就断开了，但是依然能收到正确的响应。</p><blockquote><p>打开本地回显提示：连接成功后终端是黑的，此时也可以输入命令，但不回显，所以可以先键入 <code>Ctrl + ]</code> 打开本地回显功能，再次回车，就能进入到回显模式输入命令。</p></blockquote></blockquote><p>你刚刚已经手动模拟了你的浏览器！你发送了 HTTP 请求并得到了 HTTP 响应。 这是HTTP请求的基本结构：<br><img src="https://img-blog.csdnimg.cn/2019072114343332.png" alt="LSBAWS_HTTP_request_anatomy"><br>HTTP 请求包含指明 HTTP 方法的行（<strong>GET</strong>，因为我们要求我们的服务器返回一些东西），路径 <code>/hello</code> 指示我们想要的服务器上的“页”和协议版本。</p><p>为简单起见，我们此例中的 Web 服务器此时完全忽略了上述请求行。你也可以输入任何废话而不是“GET /hello HTTP / 1.1”，你仍然可以获得“Hello，World！”响应。</p><p>一旦你键入请求行并按下 Enter 键，客户端将请求发送到服务器，服务器将读取请求行，把它打印出来并返回相应的 HTTP 响应。</p><p>以下是服务器发送回客户端的 HTTP 响应（在本例中为 telnet）：<br><img src="https://img-blog.csdnimg.cn/20190721144504166.png" alt="LSBAWS_HTTP_response_anatomy"><br>让我们剖析它看看。响应包括状态行 HTTP / 1.1 200 OK，后跟所需的空行，然后是 HTTP 响应主体。</p><p>响应状态行 HTTP / 1.1 200 OK 包含 HTTP 版本，HTTP 状态代码和 HTTP 状态代码原因短语OK。当浏览器获得响应时，它会显示响应的主体，这就是你在浏览器中看到“Hello，World！”的原因。</p><p>这就是 Web 服务器工作原理的基本模型。总结一下：Web 服务器创建一个监听套接字并通过循环接受新的连接。客户端启动 TCP 连接，并在成功建立 TCP 连接后，客户端向服务器发送 HTTP 请求，服务器响应 HTTP 响应，并显示给客户端。 要建立TCP连接，客户端和服务器都要使用套接字。</p><p>现在你有了一个非常基本的可运行的Web服务器，你可以使用浏览器或其他 HTTP 客户端进行测试。正如你所见并希望尝试的那样，你也可以通过使用 telnet 并手动输入 HTTP 请求来成为人工 HTTP 客户端。</p><p>这里有一个问题：“如何在新创建的 Web 服务器下运行 Django 应用程序，Flask 应用程序和Pyramid 应用程序，而无需对服务器进行单一更改以适应所有这些不同的 Web 框架？”</p><p>我将在本系列的 <a href="https://blog.csdn.net/Run_Bomb/article/details/96726186" target="_blank" rel="noopener">Part 2</a> 中向您展示如何去做。敬请关注。</p><p>用于准备本文的资源（链接是代理链接）：</p><ol><li><a href="https://www.amazon.com/gp/product/0131411551/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0131411551&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=2F4NYRBND566JJQL" target="_blank" rel="noopener">Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)</a></li><li><a href="https://www.amazon.com/gp/product/0321637739/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321637739&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=3ZYAKB537G6TM22J" target="_blank" rel="noopener">Advanced Programming in the UNIX Environment, 3rd Edition</a></li><li><a href="https://www.amazon.com/gp/product/1593272200/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1593272200&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=CHFOMNYXN35I2MON" target="_blank" rel="noopener">The Linux Programming Interface: A Linux and UNIX System Programming Handbook</a></li><li><a href="https://www.amazon.com/gp/product/0814420303/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0814420303&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=HY2LNXTSGPPFZ2EV" target="_blank" rel="noopener">Lead with a Story</a></li></ol><blockquote><p><strong>UPDATE: Sat, July 13, 2019</strong></p><ul><li>Updated the server code to run under Python 3.7+</li><li>Added resources used in preparation for the article</li></ul></blockquote><p><strong>此系列的所有文章（已翻译）：</strong></p><ul><li><a href="https://blog.csdn.net/Run_Bomb/article/details/96710139" target="_blank" rel="noopener">Let’s Build A Web Server. Part 1.</a></li><li><a href="https://blog.csdn.net/Run_Bomb/article/details/96726186" target="_blank" rel="noopener">Let’s Build A Web Server. Part 2.</a></li><li><a href="https://blog.csdn.net/Run_Bomb/article/details/96881972" target="_blank" rel="noopener">Let’s Build A Web Server. Part 3.</a>【未完待续..】</li></ul><hr><blockquote><p>看得出来 Ruslan 对中国谚语是感兴趣的，我们可以去他的博客 Intro: <a href="https://ruslanspivak.com/pages/about/" target="_blank" rel="noopener">About-Ruslan’s Blog</a> 认识他：</p><blockquote><p><strong><em>“I hear and I forget. I see and I remember. I do and I understand.” —— Confucius</em></strong></p></blockquote></blockquote><p>这句话翻译成我们的谚语，应该是出自荀子《儒效篇》，荀子非常重视实践的作用，他认为：“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之；学至于行之而止矣。”</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Part-1&quot;&gt;&lt;a href=&quot;#Part-1&quot; class=&quot;headerlink&quot; title=&quot;Part 1.&quot;&gt;&lt;/a&gt;Part 1.&lt;/h5&gt;&lt;p&gt;我在 &lt;a href=&quot;https://github.com/S-HuaBomb/Build-a-Web-Server-Translate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; 上开源了这个系列文章的翻译版（还在跟进原作者的更新），第一次公开翻译英文教程，纯粹兴趣使然，错漏和不严谨在所难免……欢迎提出意见和建议，或者成为 Contributor。&lt;/p&gt;&lt;p&gt;:books: :books: :books:&lt;/p&gt;&lt;p&gt;原文：《&lt;a href=&quot;https://ruslanspivak.com/lsbaws-part1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Let’s Build A Web Server. Part 1.&lt;/a&gt;》&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://s-huabomb.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Web Server" scheme="https://s-huabomb.github.io/categories/%E7%BF%BB%E8%AF%91/Web-Server/"/>
    
      <category term="Python" scheme="https://s-huabomb.github.io/categories/%E7%BF%BB%E8%AF%91/Web-Server/Python/"/>
    
    
      <category term="翻译" scheme="https://s-huabomb.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Web Server" scheme="https://s-huabomb.github.io/tags/Web-Server/"/>
    
      <category term="Python" scheme="https://s-huabomb.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>翻译：Let&#39;s Build A Web Server.Part 2</title>
    <link href="https://s-huabomb.github.io/2019/10/18/%E7%BF%BB%E8%AF%91%EF%BC%9ALet&#39;s%20Build%20A%20Web%20Server.Part%202/"/>
    <id>https://s-huabomb.github.io/2019/10/18/翻译：Let&#39;s Build A Web Server.Part 2/</id>
    <published>2019-10-18T09:31:40.000Z</published>
    <updated>2019-10-18T13:11:27.053Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2."></a>Part 2.</h5><p>我在 <a href="https://github.com/S-HuaBomb/Build-a-Web-Server-Translate" target="_blank" rel="noopener">GitHub</a> 上开源了这个系列文章的翻译版（还在跟进原作者的更新），第一次公开翻译英文教程，纯粹兴趣使然，错漏和不严谨在所难免……欢迎提出意见和建议，或者成为 Contributor。</p><p>:books: :books: :books: </p><p>原文：《<a href="https://ruslanspivak.com/lsbaws-part2/" target="_blank" rel="noopener">Let’s Build A Web Server. Part 2.</a>》</p><a id="more"></a><hr><p>还记得，在 <a href="https://blog.csdn.net/Run_Bomb/article/details/96710139" target="_blank" rel="noopener">Part 1</a> 中，我问了一个问题：“如何在新创建的 Web 服务器下运行 Django 应用程序，Flask 应用程序和 Pyramid 应用程序，而无需对服务器进行单一更改以适应所有这些不同的Web框架？”， 继续阅读，找出答案。</p><p>过去，你选择的 Python Web 框架会限制你对可用 Web 服务器的选择，反之亦然。 如果框架和服务器设计为一起工作，那么没有任何问题：<br><img src="https://img-blog.csdnimg.cn/20190721153452334.png" alt="lsbaws_part2_before_wsgi"></p><p>但是当你尝试将服务器和并非一起工作的框架组合在一起时，你可能会遇到以下问题（也许你曾经遇到过）：<br><img src="https://img-blog.csdnimg.cn/20190721153928628.png" alt="lsbaws_part2_after_wsgi"></p><p>基本上你必须使用一起工作的服务器和框架，而不是你可能想要使用的那个。</p><p>那么，你如何确保可以运行具有多个 Web 框架的 Web 服务器，而无需对 Web 服务器或 Web 框架进行代码更改？而这个问题的答案就在于 Python Web 服务器网关接口（简称WSGI，发音为“wizgy”）。<br><img src="https://img-blog.csdnimg.cn/20190721154420414.png" alt="lsbaws_part2_wsgi_idea"></p><p>WSGI 允许开发人员将 Web 框架的选择与 Web 服务器的选择分开。现在，你可以放心地混合和匹配 Web 服务器和 Web 框架，并选择适合你需求的配对。例如，你可以使用 Gunicorn 或 Nginx / uWSGI 或 Waitress 来运行 Django，Flask 或 Pyramid。 真正的混合和匹配，得益于服务器和框架中的 WSGI 支持：<br><img src="https://img-blog.csdnimg.cn/20190721155538694.png" alt="lsbaws_part2_wsgi_interop"></p><p>因此，WSGI 是我在 <a href="https://blog.csdn.net/Run_Bomb/article/details/96710139" target="_blank" rel="noopener">Part 1</a> 末尾向你提出并在本文开头重复的问题的答案。 你的 Web 服务器必须实现 WSGI 接口的服务器部分，并且所有现代 Python Web 框架都已实现了 WSGI 接口的框架端，这允许你将这些框架与 Web 服务器一起使用，而无需修改服务器的代码去适应特定的 Web 框架。</p><p>现在你知道 Web 服务器和 Web 框架的 WSGI 支持允许你选择适合你的配对，它同时对服务器和框架开发人员也是有益的，因为他们可以专注于他们擅长的专业领域而不是彼此手忙脚乱。其他语言也有类似的接口：例如，Java 有 Servlet API，Ruby 有 Rack。</p><p>现在自我感觉良好，但我打赌你会说：“Show me the code!”。好的，看看这个非常简约的 WSGI 服务器实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Python 3.7+ 测试通过 (Mac OS X)</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIServer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line">    request_queue_size = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server_address)</span>:</span></span><br><span class="line">        <span class="comment"># 创建一个监听套接字</span></span><br><span class="line">        self.listen_socket = listen_socket = socket.socket(</span><br><span class="line">            self.address_family,</span><br><span class="line">            self.socket_type</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 允许重用同一个地址</span></span><br><span class="line">        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 绑定网址</span></span><br><span class="line">        listen_socket.bind(server_address)</span><br><span class="line">        <span class="comment"># 激活（开始监听）</span></span><br><span class="line">        listen_socket.listen(self.request_queue_size)</span><br><span class="line">        <span class="comment"># 获取服务器主机和端口</span></span><br><span class="line">        host, port = self.listen_socket.getsockname()[:<span class="number">2</span>]</span><br><span class="line">        self.server_name = socket.getfqdn(host)</span><br><span class="line">        self.server_port = port</span><br><span class="line">        <span class="comment"># 用于存放 Web 框架或 Web 应用返回的请求头</span></span><br><span class="line">        self.headers_set = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_app</span><span class="params">(self, application)</span>:</span></span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span><span class="params">(self)</span>:</span></span><br><span class="line">        listen_socket = self.listen_socket</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 新的客户端连接</span></span><br><span class="line">            self.client_connection, client_address = listen_socket.accept()</span><br><span class="line">            <span class="comment"># 处理完一个请求后关闭客户端连接. 接着</span></span><br><span class="line">            <span class="comment"># 循环等待其他客户端的连接</span></span><br><span class="line">            self.handle_one_request()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_one_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        request_data = self.client_connection.recv(<span class="number">1024</span>)</span><br><span class="line">        self.request_data = request_data = request_data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="comment"># 打印格式化后的请求数据</span></span><br><span class="line">        print(<span class="string">''</span>.join(</span><br><span class="line">            <span class="string">f'&lt; <span class="subst">&#123;line&#125;</span>\n'</span> <span class="keyword">for</span> line <span class="keyword">in</span> request_data.splitlines()</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        self.parse_request(request_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用请求数据构造环境字典</span></span><br><span class="line">        env = self.get_environ()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 是时候调用我们的 application 方法并获得 HTTP 的响应主体的结果</span></span><br><span class="line">        result = self.application(env, self.start_response)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建一个响应并返回到客户端</span></span><br><span class="line">        self.finish_response(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_request</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        request_line = text.splitlines()[<span class="number">0</span>]</span><br><span class="line">        request_line = request_line.rstrip(<span class="string">'\r\n'</span>)</span><br><span class="line">        <span class="comment"># 将请求行分解为组件</span></span><br><span class="line">        (self.request_method,  <span class="comment"># GET</span></span><br><span class="line">         self.path,            <span class="comment"># /hello</span></span><br><span class="line">         self.request_version  <span class="comment"># HTTP/1.1</span></span><br><span class="line">         ) = request_line.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_environ</span><span class="params">(self)</span>:</span></span><br><span class="line">        env = &#123;&#125;</span><br><span class="line">        <span class="comment"># 以下代码段没有遵循 PEP8 约定，但它的格式与演示目的相同，以强调所需的变量及其值</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 需要用到的 WSGI 参数</span></span><br><span class="line">        env[<span class="string">'wsgi.version'</span>]      = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        env[<span class="string">'wsgi.url_scheme'</span>]   = <span class="string">'http'</span></span><br><span class="line">        env[<span class="string">'wsgi.input'</span>]        = io.StringIO(self.request_data)</span><br><span class="line">        env[<span class="string">'wsgi.errors'</span>]       = sys.stderr</span><br><span class="line">        env[<span class="string">'wsgi.multithread'</span>]  = <span class="literal">False</span></span><br><span class="line">        env[<span class="string">'wsgi.multiprocess'</span>] = <span class="literal">False</span></span><br><span class="line">        env[<span class="string">'wsgi.run_once'</span>]     = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 需要用到的 CGI 参数</span></span><br><span class="line">        env[<span class="string">'REQUEST_METHOD'</span>]    = self.request_method    <span class="comment"># GET</span></span><br><span class="line">        env[<span class="string">'PATH_INFO'</span>]         = self.path              <span class="comment"># /hello</span></span><br><span class="line">        env[<span class="string">'SERVER_NAME'</span>]       = self.server_name       <span class="comment"># localhost</span></span><br><span class="line">        env[<span class="string">'SERVER_PORT'</span>]       = str(self.server_port)  <span class="comment"># 8888</span></span><br><span class="line">        <span class="keyword">return</span> env</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(self, status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">        <span class="comment"># 添加必要的服务器请求头</span></span><br><span class="line">        server_headers = [</span><br><span class="line">            (<span class="string">'Date'</span>, <span class="string">'Mon, 15 Jul 2019 5:54:48 GMT'</span>),</span><br><span class="line">            (<span class="string">'Server'</span>, <span class="string">'WSGIServer 0.2'</span>),</span><br><span class="line">        ]</span><br><span class="line">        self.headers_set = [status, response_headers + server_headers]</span><br><span class="line">        <span class="comment"># 为了遵守 WSGI 规范，start_response 必须返回可调用的 'write'。 </span></span><br><span class="line">        <span class="comment"># 为了简单起见，我们现在忽略那个细节。返回 self.finish_response</span></span><br><span class="line">        <span class="comment"># return self.finish_response</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish_response</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            status, response_headers = self.headers_set</span><br><span class="line">            response = <span class="string">f'HTTP/1.1 <span class="subst">&#123;status&#125;</span>\r\n'</span></span><br><span class="line">            <span class="keyword">for</span> header <span class="keyword">in</span> response_headers:</span><br><span class="line">                response += <span class="string">'&#123;0&#125;: &#123;1&#125;\r\n'</span>.format(*header)</span><br><span class="line">            response += <span class="string">'\r\n'</span></span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> result:</span><br><span class="line">                response += data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="comment"># 依照 'Ctrl -v' 打印格式化后的响应数据</span></span><br><span class="line">            print(<span class="string">''</span>.join(</span><br><span class="line">                <span class="string">f'&gt; <span class="subst">&#123;line&#125;</span>\n'</span> <span class="keyword">for</span> line <span class="keyword">in</span> response.splitlines()</span><br><span class="line">            ))</span><br><span class="line">            response_bytes = response.encode()</span><br><span class="line">            self.client_connection.sendall(response_bytes)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.client_connection.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SERVER_ADDRESS = (HOST, PORT) = <span class="string">''</span>, <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_server</span><span class="params">(server_address, application)</span>:</span></span><br><span class="line">    server = WSGIServer(server_address)</span><br><span class="line">    server.set_app(application)</span><br><span class="line">    <span class="keyword">return</span> server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        sys.exit(<span class="string">'Provide a WSGI application object as module:callable'</span>)</span><br><span class="line">    app_path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    module, application = app_path.split(<span class="string">':'</span>)</span><br><span class="line">    module = __import__(module)</span><br><span class="line">    application = getattr(module, application)</span><br><span class="line">    httpd = make_server(SERVER_ADDRESS, application)</span><br><span class="line">    print(<span class="string">f'WSGIServer: Serving HTTP on port <span class="subst">&#123;PORT&#125;</span> ...\n'</span>)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure><br>它肯定比 <a href="https://blog.csdn.net/Run_Bomb/article/details/96710139" target="_blank" rel="noopener">Part 1</a> 中的服务器代码更大，但它也足够小（不到150行），你可以理解而不会被细节困扰。上面的服务器也能做到更多——它可以运行用你心爱的 Web 框架编写的基本 Web 应用程序，无论是 Pyramid，Flask，Django 还是其他一些 Python WSGI 框架。</p><p>不相信我？试一试，亲身体会吧。 将上述代码保存为 <code>webserver2.py</code> 或直接从 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/webserver2.py" target="_blank" rel="noopener">GitHub</a> 下载。 如果你试图在没有任何参数的情况下运行它，它会报错并退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python webserver2.py</span><br><span class="line">Provide a WSGI application object as module:callable</span><br></pre></td></tr></table></figure><br>它迫切地的想要为你的 Web 应用程序提供服务，这样才会变得有趣。要运行服务器，你唯一需要安装的就是 Python（确切地说是Python 3.7+）。 但要运行使用 Pyramid，Flask 和 Django 编写的应用程序，你需要先安装这些框架。让我们安装所有这三个。我首选的方法是使用 venv（默认情况下在Python 3.3及更高版本中可用）。只需按照以下步骤创建并激活虚拟环境，然后安装这三个 Web 框架。</p><blockquote><p>译者注：先创建项目目录，再在目录中创建虚拟环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir part2</span><br><span class="line">$ cd part2</span><br></pre></td></tr></table></figure><br>译者注：请注意，在一些操作系统中，你可能需要在上面的命令中使用 python 而不是 python3 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m venv lsbaws</span><br></pre></td></tr></table></figure><br>译者注：不管你用什么方法创建虚拟环境，创建完毕之后还需要激活才能够进入这个虚拟环境。 要激活你的全新虚拟环境，需使用以下命令：（以下是 Microsoft Windows 命令提示符窗口）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lsbaws\Scripts\activate</span><br><span class="line">(lsbaws) $ _</span><br></pre></td></tr></table></figure><br>译者注：激活一个虚拟环境，终端会话的环境配置就会被修改，之后你键入 <code>python</code> 的时候，实际上是调用的虚拟环境中的 Python 解释器。 此外，终端提示符也被修改成包含被激活的虚拟环境的名称的格式。这种激活是临时的和私有的，因此在关闭终端窗口时它们将不会保留，也不会影响其他的会话。 那么，当你需要同时打开多个终端窗口来调试不同的应用时，每个终端窗口都可以激活不同的虚拟环境而不会相互影响。<br>成功创建和激活了虚拟环境之后，你可以安装那三个框架了，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(lsbaws) $ pip install -U pip</span><br><span class="line">(lsbaws) $ pip install pyramid</span><br><span class="line">(lsbaws) $ pip install flask</span><br><span class="line">(lsbaws) $ pip install django</span><br></pre></td></tr></table></figure><br>译者注：我在 Windows10 命令行安装 pip 时遇到文件权限限制，修改整个 anaconda3 的文件权限无果，<br>便直接在命令行中加入<code>--user</code> ：<code>pip install --user -U pip</code> 成功安装 pip-19。</p></blockquote><p>原文作者电脑系统是 MacOS，创建虚拟环境、激活虚拟环境以及安装的过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m venv lsbaws</span><br><span class="line">$ ls lsbaws</span><br><span class="line">bin   include   lib   pyvenv.cfg</span><br><span class="line">$ source lsbaws/bin/activate</span><br><span class="line">(lsbaws) $ pip install -U pip</span><br><span class="line">(lsbaws) $ pip install pyramid</span><br><span class="line">(lsbaws) $ pip install flask</span><br><span class="line">(lsbaws) $ pip install django</span><br></pre></td></tr></table></figure><br>此时，你需要创建一个 Web 应用程序。 让我们先从 Pyramid 开始吧。 将以下代码保存为 <code>pyramidapp.py</code>，放到你保存 <code>webserver2.py</code> 的同一目录下或直接从 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/pyramidapp.py" target="_blank" rel="noopener">GitHub</a> 下载该文件：</p><blockquote><p>译者注：这些文件最好都放在上面创建的目录中，即刚刚创建的虚拟环境 <code>lsbaws</code> 的同级目录下，否则要在命令行运行这些文件时就要带上它们的绝对路径才行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyramid.config <span class="keyword">import</span> Configurator</span><br><span class="line"><span class="keyword">from</span> pyramid.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(</span><br><span class="line">        <span class="string">'Hello world from Pyramid!\n'</span>,</span><br><span class="line">        content_type=<span class="string">'text/plain'</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">config = Configurator()</span><br><span class="line">config.add_route(<span class="string">'hello'</span>, <span class="string">'/hello'</span>)</span><br><span class="line">config.add_view(hello_world, route_name=<span class="string">'hello'</span>)</span><br><span class="line">app = config.make_wsgi_app()</span><br></pre></td></tr></table></figure><br>现在，你已准备好使用自己的 Web 服务器为 Pyramid 应用程序提供服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lsbaws) $ python webserver2.py pyramidapp:app</span><br><span class="line">WSGIServer: Serving HTTP on port 8888 ...</span><br></pre></td></tr></table></figure><br>译者注：可以注意到，要在激活的虚拟环境中运行上面的命令</p></blockquote><p>你刚刚告诉你的服务器从 python 模块 ‘<em>pyramidapp</em>‘ 加载可调用的 ‘<em>app</em>‘ 。你的服务器现在已准备好接收请求并将它们转发到你的 Pyramid 应用程序。应用程序现在只处理一个路径：<code>/hello</code> 路由。在浏览器中键入 <code>http://localhost:8888/hello</code> 地址，按 Enter 键，然后观察结果：<br><img src="https://img-blog.csdnimg.cn/20190721185532139.png" alt="lsbaws_part2_browser_pyramid"></p><p>你还可以使用 <em>‘curl’</em> 工具程序在另一个命令窗口上测试这个服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v http://localhost:8888/hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>查看服务器和 <code>curl -v</code> 打印到标准输出的内容。</p><blockquote><p>译者注：这是我的运行结果：</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20190721190059614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J1bl9Cb21i,size_16,color_FFFFFF,t_70" alt="mytest-curl-pyramid"></p></blockquote></blockquote><p>现在轮到 Flask。我们按照相同的步骤。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Response</span><br><span class="line">flask_app = Flask(<span class="string">'flaskapp'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@flask_app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(</span><br><span class="line">        <span class="string">'Hello world from Flask!\n'</span>,</span><br><span class="line">        mimetype=<span class="string">'text/plain'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">app = flask_app.wsgi_app</span><br></pre></td></tr></table></figure><br>将上面的代码保存为 <code>flaskapp.py</code> 或从 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/flaskapp.py" target="_blank" rel="noopener">GitHub</a>下载，然后运行服务器如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lsbaws) $ python webserver2.py flaskapp:app</span><br><span class="line">WSGIServer: Serving HTTP on port 8888 ...</span><br></pre></td></tr></table></figure><br>现在在浏览器中键入 <code>http://localhost:8888/hello</code>，然后按 Enter 键：<br><img src="https://img-blog.csdnimg.cn/20190721190647621.png" alt="lsbaws_part2_browser_flask"></p><p>再次尝试 <em>‘curl’</em> 并亲自看看服务器返回 Flask 应用程序生成的消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v http://localhost:8888/hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>译者注：这是我的运行结果：</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20190721191218216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J1bl9Cb21i,size_16,color_FFFFFF,t_70" alt="mytest-curl-flask"></p></blockquote></blockquote><p>服务器还可以处理 Django 应用程序吗？ 试试看！但是，它有点复杂，我建议克隆整个 repo 并使用其中的 <code>djangoapp.py</code>，它是 <a href="https://github.com/rspivak/lsbaws/" target="_blank" rel="noopener">GitHub repository</a> 的一部分。这是源代码，它基本上将Django ‘helloworld’ 项目（使用 Django 的 <code>django-admin.py startproject</code> 命令预先创建）添加到当前的 Python 路径，然后导入项目的 WSGI 应用程序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">'./helloworld'</span>)</span><br><span class="line"><span class="keyword">from</span> helloworld <span class="keyword">import</span> wsgi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = wsgi.application</span><br></pre></td></tr></table></figure><br>将上面的代码保存为 <code>djangoapp.py</code> 并使用 Web 服务器运行这个 Django 应用程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lsbaws) $ python webserver2.py djangoapp:app</span><br><span class="line">WSGIServer: Serving HTTP on port 8888 ...</span><br></pre></td></tr></table></figure><br>输入以下网址，然后按 Enter 键：<br><img src="https://img-blog.csdnimg.cn/20190721192754833.png" alt="lsbaws_part2_browser_django"></p><p>就像你之前已经做过的那几次，你也可以在命令行上进行测试，并确认这次是处理你的请求的 Django 应用程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v http://localhost:8888/hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>译者注：服务器已经成功在 Windows10 下的命令行终端中挂起，但在 chrome 浏览器中访问 <code>http://localhost:8888/hello</code> 时出现 <code>DisallowedHost at /Invalid HTTP_HOST header: &#39;DESKTOP-E61P8KD:8888&#39;. You may need to add &#39;desktop-e61p8kd&#39; to ALLOWED_HOSTS.</code> 这样的错误。暂且搁置，待日后重提。</p></blockquote><p>你试过吗？你已经确认了这个服务器能和这三个框架一起工作了吗？ 如果没有，那么请试一试。 阅读很重要，但这个系列是关于重构的，这意味着你需要亲力亲为。去尝试吧，我会等着你，别担心。不是说，你必须尝试它，只是那样的话会更好，自己重新输入所有内容，并确保它按预想的那样运行。</p><p>好的，你已经体验过 WSGI 的强大功能：它允许你混合搭配 Web 服务器和 Web 框架。 WSGI 在Python Web 服务器和 Python Web 框架之间提供了一个最小的接口。它非常简单，并且很容易在服务器端和框架端实现。以下代码段显示了接口的服务器端和框架端：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_application</span><span class="params">(application)</span>:</span></span><br><span class="line">    <span class="string">"""Server code."""</span></span><br><span class="line">    <span class="comment"># 这是应用程序/框架存储 HTTP 状态和 HTTP 响应头的位置，供服务器传输到客户端</span></span><br><span class="line">    headers_set = []</span><br><span class="line">    <span class="comment"># 带有 WSGI / CGI 变量的环境字典</span></span><br><span class="line">    environ = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">        headers_set[:] = [status, response_headers]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 服务器调用'application'并返回响应主体</span></span><br><span class="line">    result = application(environ, start_response)</span><br><span class="line">    <span class="comment"># 服务器构建HTTP响应并将其传输到客户端</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""A barebones WSGI app."""</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b'Hello world!'</span>]</span><br><span class="line"></span><br><span class="line">run_application(app)</span><br></pre></td></tr></table></figure><br>以下是它的运行方式：</p><ol><li>框架提供了一个可调用的 <em>“application”</em>（WSGI 规范没有规定应该如何实现）</li><li>服务器为从 HTTP 客户端接收的每个请求调用 <em>“application”</em> 。 它传递一个包含 WSGI / CGI 变量的字典 <em>‘environ’</em> 和一个可调用 <em>‘start_response’</em> 作为 <em>‘application’</em> 的参数。</li><li>框架 / 应用程序生成 HTTP 状态和 HTTP 响应标头，并将它们传递给可调用的 <em>“start_response”</em>，以便服务器存储它们。框架 / 应用程序还返回响应主体。</li><li>服务器将状态、响应头和响应主体组合成 HTTP 响应并将其发送到客户端（此步骤不是规范的一部分，但它是流程中的下一个逻辑步骤，为了清楚起见我添加进来）</li></ol><p>以下是这个接口的直观展示：<br><img src="https://img-blog.csdnimg.cn/20190721205141288.png" alt="lsbaws_part2_wsgi_interface"></p><p>到目前为止，你已经看过 Pyramid、Flask 和 Django Web 应用程序，并且你已经看到了实现服务器端 WSGI 规范的服务器代码。你甚至已经看到了不使用任何框架的非正式 WSGI 应用程序代码片段。</p><p>问题在于，当你使用其中一个框架编写 Web 应用程序时，你在更高级别的层次工作而不是直接使用 WSGI，但我知道你对 WSGI 接口的框架方面也很好奇，因为你在读这篇文章。因此，让我们创建一个简约的 WSGI Web 应用程序 / Web 框架，而不使用 Pyramid、Flask 或 Django，并在你的服务器上运行它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""A barebones WSGI application.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is a starting point for your own Web framework :)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b'Hello world from a simple WSGI application!\n'</span>]</span><br></pre></td></tr></table></figure><br>再次，将上述代码保存成 <code>wsgiapp.py</code> 文件或直接从 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/wsgiapp.py" target="_blank" rel="noopener">GitHub</a> 下载并在 Web 服务器下运行应用程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lsbaws) $ python webserver2.py wsgiapp:app</span><br><span class="line">WSGIServer: Serving HTTP on port 8888 ...</span><br></pre></td></tr></table></figure><br>输入以下网址，然后按 Enter 键。 你应该看到这样的结果：<br><img src="https://img-blog.csdnimg.cn/20190721210736385.png" alt="lsbaws_part2_browser_simple_wsgi_app"></p><p>在学习如何创建 Web 服务器的同时，你刚刚编写了自己的简约 WSGI Web 框架！不得了啊。</p><p>现在，让我们回到服务器传输给客户端的内容。 以下是使用 HTTP 客户端调用 Pyramid 应用程序时服务器生成的 HTTP 响应：<br><img src="https://img-blog.csdnimg.cn/20190721211208398.png" alt="lsbaws_part2_http_response"></p><p>响应中有一些你在 <a href="https://blog.csdn.net/Run_Bomb/article/details/96710139" target="_blank" rel="noopener">Part 1</a> 中看到的熟悉部分，但它也有一些新的东西。例如，它有四个你以前没有见过的 HTTP 标头：<em>Content-Type，Content-Length，Date</em> 和 <em>Server</em>。 这些是来自 Web 服务器的响应通常应该具有的标头。但是，没有一个是严格要求的。标头的目的是传输有关 HTTP 请求 / 响应的其他信息。</p><p>现在你已经了解了有关 WSGI 接口的更多信息，以下是同样的 HTTP 响应，其中包含有关生成它的部件的更多信息：<br><img src="https://img-blog.csdnimg.cn/20190721212122891.png" alt="lsbaws_part2_http_response_explanation"></p><p>我还没有提到过 <em>‘environ’</em> 字典，但基本上它是一个 Python 字典，必须包含 WSGI 规范规定的某些 WSGI 和 CGI 参数变量。解析请求后，服务器从 HTTP 请求中获取字典的值。这就是字典的内容：<br><img src="https://img-blog.csdnimg.cn/20190721212338260.png" alt="lsbaws_part2_environ"></p><p>Web 框架使用来自该字典的信息来决定指定的路由、请求方法等使用哪个视图，从哪里读取请求主体以及在何处写入错误（如果有的话）。</p><p>到目前为止，你已经创建了自己的 WSGI Web 服务器，并且已经使用不同的 Web 框架编写了 Web 应用程序。而且，你还在此过程中创建了你的准系统 Web 应用程序 / Web 框架。这是一段艰难的旅程。让我们回顾一下你的 WSGI Web 服务器必须做什么来提供针对 WSGI 应用程序的请求：</p><ul><li>首先，服务器启动并加载由 Web 框架 / 应用程序提供的可调用 <em>“application”</em></li><li>然后，服务器读取一个请求</li><li>接着，服务器解析这个请求</li><li>再者，然后，服务器使用请求数据构建 <em>“environ”</em> 字典</li><li>然后，服务器调用可调用的 <em>“application”</em>、<em>“environ”</em> 字典和可调用的 <em>“start_response”</em> 作为参数并返回响应主体。</li><li>接着，服务器使用可调用 <em>‘application’</em> 对象返回的数据以及 <em>‘start_response’</em> 设置的状态和响应头来构造 HTTP 响应。</li><li>最后，服务器将这个 HTTP 响应返回给客户端<br><img src="https://img-blog.csdnimg.cn/2019072121363354.png" alt="lsbaws_part2_server_summary"></li></ul><p>这就是它的全部内容。你现在拥有一个可用的 WSGI 服务器，可以为使用 WSGI 兼容的 Web 框架（如 Django，Flask，Pyramid 或你自己的 WSGI 框架）编写的基本 Web 应用程序提供服务。最好的一点就是服务器可以与多个 Web 框架一起使用，而无需对服务器代码库进行任何更改。简直漂亮。</p><p>在你继续之前，这是另一个你可以考虑一下的问题：“你如何让你的服务器一次处理多个请求？”</p><p>请继续关注，我将在 <a href="https://blog.csdn.net/Run_Bomb/article/details/96881972" target="_blank" rel="noopener">Part 3</a> 中向你展示完成它的一种方法。Cheers！</p><blockquote><p><strong>UPDATE: Mon, July 15, 2019</strong></p><ul><li>Updated the server code to run under Python 3.7+</li><li>Added resources used in preparation for the article</li></ul></blockquote><p><strong>此系列的所有文章（已翻译）：</strong></p><ul><li><a href="https://blog.csdn.net/Run_Bomb/article/details/96710139" target="_blank" rel="noopener">Let’s Build A Web Server. Part 1.</a></li><li><a href="https://blog.csdn.net/Run_Bomb/article/details/96726186" target="_blank" rel="noopener">Let’s Build A Web Server. Part 2.</a></li><li><a href="https://blog.csdn.net/Run_Bomb/article/details/96881972" target="_blank" rel="noopener">Let’s Build A Web Server. Part 3.</a>【未完待续..】</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Part-2&quot;&gt;&lt;a href=&quot;#Part-2&quot; class=&quot;headerlink&quot; title=&quot;Part 2.&quot;&gt;&lt;/a&gt;Part 2.&lt;/h5&gt;&lt;p&gt;我在 &lt;a href=&quot;https://github.com/S-HuaBomb/Build-a-Web-Server-Translate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; 上开源了这个系列文章的翻译版（还在跟进原作者的更新），第一次公开翻译英文教程，纯粹兴趣使然，错漏和不严谨在所难免……欢迎提出意见和建议，或者成为 Contributor。&lt;/p&gt;&lt;p&gt;:books: :books: :books: &lt;/p&gt;&lt;p&gt;原文：《&lt;a href=&quot;https://ruslanspivak.com/lsbaws-part2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Let’s Build A Web Server. Part 2.&lt;/a&gt;》&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://s-huabomb.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Web Server" scheme="https://s-huabomb.github.io/categories/%E7%BF%BB%E8%AF%91/Web-Server/"/>
    
      <category term="Python" scheme="https://s-huabomb.github.io/categories/%E7%BF%BB%E8%AF%91/Web-Server/Python/"/>
    
    
      <category term="翻译" scheme="https://s-huabomb.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Web Server" scheme="https://s-huabomb.github.io/tags/Web-Server/"/>
    
      <category term="Python" scheme="https://s-huabomb.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://s-huabomb.github.io/2019/10/18/hello-world/"/>
    <id>https://s-huabomb.github.io/2019/10/18/hello-world/</id>
    <published>2019-10-18T06:49:49.370Z</published>
    <updated>2019-10-18T13:11:34.464Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
